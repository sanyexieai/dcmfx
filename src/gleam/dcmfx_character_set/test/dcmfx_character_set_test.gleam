import dcmfx_character_set
import dcmfx_character_set/string_type.{type StringType}
import gleam/list
import gleam/string
import gleeunit
import gleeunit/should

pub fn main() {
  gleeunit.main()
}

pub fn specific_character_set_test() {
  ""
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "ISO_IR 144"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "ISO IR 144"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "iso-ir 144"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "\\ISO_IR 144"
  |> dcmfx_character_set.from_string
  |> should.be_error

  "\\ISO 2022 IR 144"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "ISO 2022 IR 6\\ISO 2022 IR 87"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "ISO_IR 6\\ISO 2022 IR 87"
  |> dcmfx_character_set.from_string
  |> should.be_error

  "ISO_IR 192"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "ISO_IR 192\\ISO 2022 IR 149"
  |> dcmfx_character_set.from_string
  |> should.be_error

  "GB18030"
  |> dcmfx_character_set.from_string
  |> should.be_ok

  "GB18030\\ISO_IR 192"
  |> dcmfx_character_set.from_string
  |> should.be_error

  "ISO_IR 90210"
  |> dcmfx_character_set.from_string
  |> should.be_error
}

pub fn decode_bytes_single_byte_without_extensions_test() {
  // Test decoding of ISO IR 100 bytes (ISO 646, US-ASCII)
  decode_bytes(
    "ISO_IR 6",
    <<0x48, 0x65, 0x6C, 0x6C, 0x6F>>,
    string_type.PersonName,
  )
  |> should.equal("Hello")

  // Test decoding of ISO IR 100 bytes (ISO 8859-1, Latin-1)
  decode_bytes(
    "ISO_IR 100",
    <<0x42, 0x75, 0x63, 0x5E, 0x4A, 0xE9, 0x72, 0xF4, 0x6D, 0x65>>,
    string_type.PersonName,
  )
  |> should.equal("Buc^Jérôme")

  // Test decoding of ISO IR 101 bytes (ISO 8859-2, Latin-2)
  decode_bytes(
    "ISO_IR 101",
    <<0x57, 0x61, 0xB3, 0xEA, 0x73, 0x61>>,
    string_type.PersonName,
  )
  |> should.equal("Wałęsa")

  // Test decoding of ISO IR 109 bytes (ISO 8859-3, Latin-3)
  decode_bytes(
    "ISO_IR 109",
    <<0x61, 0x6E, 0x74, 0x61, 0xFD, 0x6E, 0x6F, 0x6D, 0x6F>>,
    string_type.PersonName,
  )
  |> should.equal("antaŭnomo")

  // Test decoding of ISO IR 110 bytes (ISO 8859-4, Latin-4)
  decode_bytes(
    "ISO_IR 110",
    <<0x76, 0xE0, 0x72, 0x64, 0x73>>,
    string_type.PersonName,
  )
  |> should.equal("vārds")

  // Test decoding of ISO IR 144 bytes (ISO 8859-5, Latin/Cyrillic)
  decode_bytes(
    "ISO_IR 144",
    <<0xBB, 0xEE, 0xDA, 0x63, 0x65, 0xDC, 0xD1, 0x79, 0x70, 0xD3>>,
    string_type.PersonName,
  )
  |> should.equal("Люкceмбypг")

  // Test decoding of ISO IR 127 bytes (ISO 8859-6, Latin/Arabic)
  decode_bytes(
    "ISO_IR 127",
    <<0xE2, 0xC8, 0xC7, 0xE6, 0xEA, 0x5E, 0xE4, 0xE6, 0xD2, 0xC7, 0xD1, 0x20>>,
    string_type.PersonName,
  )
  |> should.equal("قباني^لنزار")

  // Test decoding of ISO IR 126 bytes (ISO 8859-7, Latin/Greek)
  decode_bytes(
    "ISO_IR 126",
    <<0xC4, 0xE9, 0xEF, 0xED, 0xF5, 0xF3, 0xE9, 0xEF, 0xF2>>,
    string_type.PersonName,
  )
  |> should.equal("Διονυσιος")

  // Test decoding of ISO IR 138 bytes (ISO 8859-8, Latin/Hebrew)
  decode_bytes(
    "ISO_IR 138",
    <<0xF9, 0xF8, 0xE5, 0xEF, 0x5E, 0xE3, 0xE1, 0xE5, 0xF8, 0xE4>>,
    string_type.PersonName,
  )
  |> should.equal("שרון^דבורה")

  // Test decoding of ISO IR 148 bytes (ISO 8859-9 and Latin-5)
  decode_bytes(
    "ISO_IR 148",
    <<0xC7, 0x61, 0x76, 0x75, 0xFE, 0x6F, 0xF0, 0x6C, 0x75>>,
    string_type.PersonName,
  )
  |> should.equal("Çavuşoğlu")

  // Test decoding of ISO IR 203 bytes (ISO 8859-15 and Latin-9)
  decode_bytes(
    "ISO_IR 203",
    <<0xC7, 0x61, 0x76, 0x75, 0xFE, 0x6F, 0xF0, 0x6C, 0x75>>,
    string_type.PersonName,
  )
  |> should.equal("Çavuþoðlu")

  // Test decoding of ISO IR 13 bytes (JIS X 0201)
  decode_bytes(
    "ISO_IR 13",
    <<0xD4, 0xCF, 0xC0, 0xDE, 0x5E, 0xC0, 0xDB, 0xB3>>,
    string_type.PersonName,
  )
  |> should.equal("ﾔﾏﾀﾞ^ﾀﾛｳ")

  // Test that an 0x5C byte results in the Yen symbol when using JIS X 0201 to
  // decode a string value without multiplicity
  decode_bytes(
    "ISO_IR 13",
    <<0xA6, 0xDD, 0xDF, 0x5C, 0x7E>>,
    string_type.SingleValue,
  )
  |> should.equal("ｦﾝﾟ¥‾")

  // Test that an 0x5C byte results in a backslash when using JIS X 0201 to
  // decode a string value with multiplicity
  decode_bytes(
    "ISO_IR 13",
    <<0xA6, 0xDD, 0xDF, 0x5C, 0x7E>>,
    string_type.MultiValue,
  )
  |> should.equal("ｦﾝﾟ\\‾")

  // Test decoding of ISO IR 166 bytes (ISO 8859-11, TIS 620-2533)
  decode_bytes(
    "ISO_IR 166",
    <<0xB9, 0xD2, 0xC1, 0xCA, 0xA1, 0xD8, 0xC5>>,
    string_type.PersonName,
  )
  |> should.equal("นามสกุล")
}

pub fn decode_bytes_single_byte_with_extensions_test() {
  // Test decoding of ISO 2022 IR 127 bytes (ISO 8859-6, Latin/Arabic) with no
  // escape sequence
  decode_bytes(
    "ISO 2022 IR 127",
    <<
      0xE2, 0xC8, 0xC7, 0xE6, 0xEA, 0x5E, 0x1B, 0x2D, 0x47, 0xE4, 0xE6, 0xD2,
      0xC7, 0xD1,
    >>,
    string_type.PersonName,
  )
  |> should.equal("قباني^لنزار")

  // Test decoding of ISO 2022 IR 126 bytes (ISO 8859-7, Latin/Greek) with an
  // escape sequence
  decode_bytes(
    "ISO 2022 IR 126",
    <<0x1B, 0x2D, 0x46, 0xC4, 0xE9, 0xEF, 0xED, 0xF5, 0xF3, 0xE9, 0xEF, 0xF2>>,
    string_type.PersonName,
  )
  |> should.equal("Διονυσιος")

  // Test decoding of multiple values in different single-byte encodings
  decode_bytes(
    "ISO 2022 IR 100\\ISO 2022 IR 144\\ISO 2022 IR 126",
    <<
      0x42, 0x75, 0x63, 0x5E, 0x4A, 0xE9, 0x72, 0xF4, 0x6D, 0x65, 0x5C, 0x1B,
      0x2D, 0x46, 0xC4, 0xE9, 0xEF, 0xED, 0xF5, 0xF3, 0xE9, 0xEF, 0xF2, 0x5C,
      0x1B, 0x2D, 0x4C, 0xBB, 0xEE, 0xDA, 0x63, 0x65, 0xDC, 0xD1, 0x79, 0x70,
      0xD3,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Buc^Jérôme\\Διονυσιος\\Люкceмбypг")

  // Test decoding of an invalid escape sequence, it should be ignored
  decode_bytes(
    "ISO 2022 IR 126",
    <<0x1B, 0x2D, 0x46, 0xC4, 0x1B, 0xC4>>,
    string_type.SingleValue,
  )
  |> should.equal("ΔΔ")

  // Test decoding falls back to the default character set when trying to use
  // an absent code element
  decode_bytes("ISO 2022 IR 149", <<0x41, 0x42>>, string_type.SingleValue)
  |> should.equal("AB")
}

/// Tests that the relevant delimiters for each string type reset the character
/// set correctly.
///
pub fn decode_bytes_iso_2022_delimiters_test() {
  [
    #(string_type.SingleValue, [0x09, 0x0A, 0x0C, 0x0D], [0x5C, 0x3D, 0x5E]),
    #(string_type.MultiValue, [0x09, 0x0A, 0x0C, 0x0D, 0x5C], [0x3D, 0x5E]),
    #(string_type.PersonName, [0x09, 0x0A, 0x0C, 0x0D, 0x5C, 0x3D, 0x5E], []),
  ]
  |> list.each(fn(x) {
    let #(string_type, delimiters, non_delimiters) = x

    delimiters
    |> list.each(fn(delimiter) {
      let assert Ok(cp) = string.utf_codepoint(delimiter)

      decode_bytes(
        "ISO 2022 IR 148\\ISO 2022 IR 126",
        <<0x1B, 0x2D, 0x46, 0xED, delimiter, 0xED>>,
        string_type,
      )
      |> should.equal("ν" <> string.from_utf_codepoints([cp]) <> "í")
    })

    non_delimiters
    |> list.each(fn(non_delimiter) {
      let assert Ok(cp) = string.utf_codepoint(non_delimiter)

      decode_bytes(
        "ISO 2022 IR 148\\ISO 2022 IR 126",
        <<0x1B, 0x2D, 0x46, 0xED, non_delimiter, 0xED>>,
        string_type,
      )
      |> should.equal("ν" <> string.from_utf_codepoints([cp]) <> "ν")
    })
  })
}

pub fn decode_bytes_multi_byte_with_extensions_test() {
  // Test decoding of ISO 2002 IR 87 bytes (JIS X 0208)
  decode_bytes(
    "ISO 2022 IR 87",
    <<0x57, 0x5A, 0x61, 0x4F>>,
    string_type.SingleValue,
  )
  |> should.equal("忱疣")

  // Test that a 0x5C lead byte is not treated as a backslash when decoding JIS
  // X 0208 bytes
  decode_bytes("ISO 2022 IR 87", <<0x5C, 0x41>>, string_type.MultiValue)
  |> should.equal("楞")

  // Test decoding of ISO 2002 IR 159 bytes (JIS X 0212)
  decode_bytes(
    "ISO 2022 IR 159",
    <<0x57, 0x5A, 0x61, 0x4F>>,
    string_type.SingleValue,
  )
  |> should.equal("苷逘")

  // Test decoding of ISO 2002 IR 149 bytes (KS X 1001)
  decode_bytes(
    "ISO 2022 IR 149",
    <<0xB1, 0xE8, 0xC8, 0xF1, 0xC1, 0xDF>>,
    string_type.PersonName,
  )
  |> should.equal("김희중")

  // Test decoding of ISO 2002 IR 58 bytes (GB 2312)
  decode_bytes(
    "ISO 2022 IR 58",
    <<0xB5, 0xDA, 0xD2, 0xBB, 0xD0, 0xD0, 0xCE, 0xC4, 0xD7, 0xD6, 0xA1, 0xA3>>,
    string_type.PersonName,
  )
  |> should.equal("第一行文字。")

  // Test decoding with a multi-byte character set as the second character set
  decode_bytes(
    "\\ISO 2022 IR 149",
    <<
      0x1B, 0x24, 0x29, 0x43, 0xB1, 0xE8, 0xC8, 0xF1, 0xC1, 0xDF, 0x1B, 0x28,
      0x42, 0x5C, 0x1B, 0x24, 0x29, 0x43, 0xB1, 0xE8, 0xC8, 0xF1, 0xC1, 0xDF,
      0x1B, 0x28, 0x42, 0x20,
    >>,
    string_type.PersonName,
  )
  |> should.equal("김희중\\김희중")

  // Test decoding using two different multi-byte character sets
  decode_bytes(
    "ISO 2022 IR 87\\ISO 2022 IR 149",
    <<
      0x1B, 0x24, 0x29, 0x43, 0xD1, 0xCE, 0xD4, 0xD7, 0x21, 0x38, 0x22, 0x76,
      0x30, 0x21, 0x3B, 0x33, 0x45, 0x44, 0x1B, 0x24, 0x42, 0x57, 0x5A, 0x61,
      0x4F,
    >>,
    string_type.PersonName,
  )
  |> should.equal("吉洞仝♪亜山田忱疣")

  // Test use of ISO 2022 IR 6 even when it isn't explicitly specified
  decode_bytes(
    "ISO 2022 IR 13\\ISO 2022 IR 87",
    <<
      0xD4, 0xCF, 0xC0, 0xDE, 0x5E, 0xC0, 0xDB, 0xB3, 0x3D, 0x1B, 0x24, 0x42,
      0x3B, 0x33, 0x45, 0x44, 0x1B, 0x28, 0x42, 0x5E, 0x1B, 0x24, 0x42, 0x42,
      0x40, 0x4F, 0x3A, 0x1B, 0x28, 0x42, 0x3D, 0x1B, 0x24, 0x42, 0x24, 0x64,
      0x24, 0x5E, 0x24, 0x40, 0x1B, 0x28, 0x42, 0x5E, 0x1B, 0x24, 0x42, 0x24,
      0x3F, 0x24, 0x6D, 0x24, 0x26, 0x1B, 0x28, 0x42,
    >>,
    string_type.PersonName,
  )
  |> should.equal("ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう")
}

pub fn decode_bytes_multi_byte_without_extensions_test() {
  // Test decoding of ISO IR 192 bytes (UTF-8)
  decode_bytes(
    "ISO_IR 192",
    <<
      0x57, 0x61, 0x6E, 0x67, 0x5E, 0x58, 0x69, 0x61, 0x6F, 0x44, 0x6F, 0x6E,
      0x67, 0x3D, 0xE7, 0x8E, 0x8B, 0x5E, 0xE5, 0xB0, 0x8F, 0xE6, 0x9D, 0xB1,
      0x3D, 0x20,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Wang^XiaoDong=王^小東=")

  // Test decoding of GB 18030 bytes
  decode_bytes(
    "GB18030",
    <<
      0x57, 0x61, 0x6E, 0x67, 0x5E, 0x58, 0x69, 0x61, 0x6F, 0x44, 0x6F, 0x6E,
      0x67, 0x3D, 0xCD, 0xF5, 0x5E, 0xD0, 0xA1, 0xB6, 0xAB, 0x3D,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Wang^XiaoDong=王^小东=")

  // Test decoding of GBK bytes
  decode_bytes("GBK", <<0xD0, 0xA1, 0xB6, 0xAB>>, string_type.SingleValue)
  |> should.equal("小东")
}

/// Tests adapted from the examples in the annexes of the DICOM standard.
///
pub fn decode_bytes_dicom_annex_examples_test() {
  //
  // Test examples from Annex H of the DICOM standard (Japanese)
  //

  decode_bytes(
    "\\ISO 2022 IR 87",
    <<
      0x59, 0x61, 0x6D, 0x61, 0x64, 0x61, 0x5E, 0x54, 0x61, 0x72, 0x6F, 0x75,
      0x3D, 0x1B, 0x24, 0x42, 0x3B, 0x33, 0x45, 0x44, 0x1B, 0x28, 0x42, 0x5E,
      0x1B, 0x24, 0x42, 0x42, 0x40, 0x4F, 0x3A, 0x1B, 0x28, 0x42, 0x3D, 0x1B,
      0x24, 0x42, 0x24, 0x64, 0x24, 0x5E, 0x24, 0x40, 0x1B, 0x28, 0x42, 0x5E,
      0x1B, 0x24, 0x42, 0x24, 0x3F, 0x24, 0x6D, 0x24, 0x26, 0x1B, 0x28, 0x42,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Yamada^Tarou=山田^太郎=やまだ^たろう")

  decode_bytes(
    "ISO 2022 IR 13\\ISO 2022 IR 87",
    <<
      0xD4, 0xCF, 0xC0, 0xDE, 0x5E, 0xC0, 0xDB, 0xB3, 0x3D, 0x1B, 0x24, 0x42,
      0x3B, 0x33, 0x45, 0x44, 0x1B, 0x28, 0x4A, 0x5E, 0x1B, 0x24, 0x42, 0x42,
      0x40, 0x4F, 0x3A, 0x1B, 0x28, 0x4A, 0x3D, 0x1B, 0x24, 0x42, 0x24, 0x64,
      0x24, 0x5E, 0x24, 0x40, 0x1B, 0x28, 0x4A, 0x5E, 0x1B, 0x24, 0x42, 0x24,
      0x3F, 0x24, 0x6D, 0x24, 0x26, 0x1B, 0x28, 0x4A,
    >>,
    string_type.PersonName,
  )
  |> should.equal("ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう")

  //
  // Test examples from Annex I of the DICOM standard (Korean)
  //

  decode_bytes(
    "\\ISO 2022 IR 149",
    <<
      0x48, 0x6F, 0x6E, 0x67, 0x5E, 0x47, 0x69, 0x6C, 0x64, 0x6F, 0x6E, 0x67,
      0x3D, 0x1B, 0x24, 0x29, 0x43, 0xFB, 0xF3, 0x5E, 0x1B, 0x24, 0x29, 0x43,
      0xD1, 0xCE, 0xD4, 0xD7, 0x3D, 0x1B, 0x24, 0x29, 0x43, 0xC8, 0xAB, 0x5E,
      0x1B, 0x24, 0x29, 0x43, 0xB1, 0xE6, 0xB5, 0xBF,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Hong^Gildong=洪^吉洞=홍^길동")

  //
  // Test examples from Annex J of the DICOM standard (Chinese)
  //

  decode_bytes(
    "ISO_IR 192",
    <<
      0x57, 0x61, 0x6E, 0x67, 0x5E, 0x58, 0x69, 0x61, 0x6F, 0x44, 0x6F, 0x6E,
      0x67, 0x3D, 0xE7, 0x8E, 0x8B, 0x5E, 0xE5, 0xB0, 0x8F, 0xE6, 0x9D, 0xB1,
      0x3D,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Wang^XiaoDong=王^小東=")

  decode_bytes(
    "ISO_IR 192",
    <<
      0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6C, 0x69,
      0x6E, 0x65, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x73, 0xE4,
      0xB8, 0xAD, 0xE6, 0x96, 0x87, 0x2E, 0x0D, 0x0A, 0x54, 0x68, 0x65, 0x20,
      0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20,
      0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x73, 0xE4, 0xB8, 0xAD, 0xE6,
      0x96, 0x87, 0x2C, 0x20, 0x74, 0x6F, 0x6F, 0x2E, 0x0D, 0x0A, 0x54, 0x68,
      0x65, 0x20, 0x74, 0x68, 0x69, 0x72, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65,
      0x2E, 0x0D, 0x0A,
    >>,
    string_type.MultiValue,
  )
  |> should.equal(
    "The first line includes中文.\r\n"
    <> "The second line includes中文, too.\r\n"
    <> "The third line.\r\n",
  )

  decode_bytes(
    "GB18030",
    <<
      0x57, 0x61, 0x6E, 0x67, 0x5E, 0x58, 0x69, 0x61, 0x6F, 0x44, 0x6F, 0x6E,
      0x67, 0x3D, 0xCD, 0xF5, 0x5E, 0xD0, 0xA1, 0xB6, 0xAB, 0x3D,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Wang^XiaoDong=王^小东=")

  decode_bytes(
    "GB18030",
    <<
      0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6C, 0x69,
      0x6E, 0x65, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x73, 0xD6,
      0xD0, 0xCE, 0xC4, 0x2E, 0x0D, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65,
      0x63, 0x6F, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x69, 0x6E,
      0x63, 0x6C, 0x75, 0x64, 0x65, 0x73, 0xD6, 0xD0, 0xCE, 0xC4, 0x2C, 0x20,
      0x74, 0x6F, 0x6F, 0x2E, 0x0D, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x74, 0x68,
      0x69, 0x72, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0x0D, 0x0A,
    >>,
    string_type.MultiValue,
  )
  |> should.equal(
    "The first line includes中文.\r\n"
    <> "The second line includes中文, too.\r\n"
    <> "The third line.\r\n",
  )

  //
  // Test examples from Annex K of the DICOM standard (Chinese)
  //

  decode_bytes(
    "\\ISO 2022 IR 58",
    <<
      0x5A, 0x68, 0x61, 0x6E, 0x67, 0x5E, 0x58, 0x69, 0x61, 0x6F, 0x44, 0x6F,
      0x6E, 0x67, 0x3D, 0x1B, 0x24, 0x29, 0x41, 0xD5, 0xC5, 0x5E, 0x1B, 0x24,
      0x29, 0x41, 0xD0, 0xA1, 0xB6, 0xAB, 0x3D, 0x20,
    >>,
    string_type.PersonName,
  )
  |> should.equal("Zhang^XiaoDong=张^小东=")

  decode_bytes(
    "\\ISO 2022 IR 58",
    <<
      0x31, 0x2E, 0x1B, 0x24, 0x29, 0x41, 0xB5, 0xDA, 0xD2, 0xBB, 0xD0, 0xD0,
      0xCE, 0xC4, 0xD7, 0xD6, 0xA1, 0xA3, 0x0D, 0x0A,
    >>,
    string_type.PersonName,
  )
  |> should.equal("1.第一行文字。\r\n")

  decode_bytes(
    "\\ISO 2022 IR 58",
    <<
      0x32, 0x2E, 0x1B, 0x24, 0x29, 0x41, 0xB5, 0xDA, 0xB6, 0xFE, 0xD0, 0xD0,
      0xCE, 0xC4, 0xD7, 0xD6, 0xA1, 0xA3, 0x0D, 0x0A,
    >>,
    string_type.PersonName,
  )
  |> should.equal("2.第二行文字。\r\n")

  decode_bytes(
    "\\ISO 2022 IR 58",
    <<
      0x33, 0x2E, 0x1B, 0x24, 0x29, 0x41, 0xB5, 0xDA, 0xC8, 0xFD, 0xD0, 0xD0,
      0xCE, 0xC4, 0xD7, 0xD6, 0xA1, 0xA3, 0x0D, 0x0A,
    >>,
    string_type.PersonName,
  )
  |> should.equal("3.第三行文字。\r\n")
}

fn decode_bytes(
  specific_character_set: String,
  bytes: BitArray,
  string_type: StringType,
) {
  let assert Ok(charset) =
    dcmfx_character_set.from_string(specific_character_set)

  dcmfx_character_set.decode_bytes(charset, bytes, string_type)
}

pub fn sanitize_default_charset_bytes_test() {
  <<>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<>>)

  <<0x40, 0x50, 0x60>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<0x40, 0x50, 0x60>>)

  <<0xDD, 0x50, 0x60>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<0x3F, 0x50, 0x60>>)

  <<0x40, 0xDD, 0x60>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<0x40, 0x3F, 0x60>>)

  <<0x40, 0x50, 0xDD>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<0x40, 0x50, 0x3F>>)

  <<0xDD, 0xDD, 0xDD>>
  |> dcmfx_character_set.sanitize_default_charset_bytes
  |> should.equal(<<0x3F, 0x3F, 0x3F>>)
}
